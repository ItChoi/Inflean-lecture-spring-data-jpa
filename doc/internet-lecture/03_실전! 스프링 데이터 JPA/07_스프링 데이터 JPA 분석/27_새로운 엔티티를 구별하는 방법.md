## 새로운 엔티티를 구별하는 방법
- save 
  - 새로운 엔티티면 new -> pk가 null & 0이면 새로운
    - JPA가 persist 하면 그 안에서 id가 생성! 
    - 식별자가 객체일땐 null (Long)
    - 기본타입일 땐 0으로 판단 (long)
    - 만약에 @Id에 제너레이티드 밸류를 안썼다면?
      - 기본 타입은 값이 있기 때문에 (0) -> 새로 생성 안하고 merge로 가버린다.
        - db에 있을 것이라고 가정하는 것이 merge! -> A가 있는 지 찾아 온다! 
          - 없으면 새거라고 생각해서 insert가 나간다. (비효율)
          - 데이터 변경은 변경 감지 기능을 쓰자! 저장은 persist! 
          - 굉장히 특수한 상황이 아닌 이상 merge를 쓰지 말자!
          - 영속성 컨텍스트가 detach되는 상황도 거의 없다.
  - 새로운 엔티티가 아니면 merge
- 제너레이티드 밸류를 못쓰는 경우?
  - 웬만하면 깔고 들어가지만, 어쩔 수 없이 id를 임의로 생성해야 될 때는 Persistable인터페이스를 제공한다! 
    - public class Item implements Persistable<String>를 해서 구현해야 한다.
      - Override isNew() -> 새로 만들었는지 아닌지 로직을 짜야 한다.
      - Override getId
      - @CreatedDate private LocalDateTime createdDate;하고 Entity 클래스에 @EntityListeners(AuditingEntityListener.class) 추가 (사실 이건 baseEntity 등을 통해 해결되어 있을 듯)
        - @CreatedDate는 JPA 이벤트! persist가 되기전에 호출되는 애노테이션이다.
        - 따라서 isNew를 푸는 방법 -> createdDate가 null이냐? null이면 새로운 객체로 보고, 값이 있으면, 이미 JPA를 통해 값이 들어간 것으로 판단!
        