## 스프링 데이터 JPA 구현체 분석
- 스프링 데이터 JPA가 내부적으로 어떻게 동작 하는 지 
  - 구현체 분석
  - 코드 레벨로 쏙 들어가서 분석!
- 스프링 데이터 JPA 공통!
  - SimpleJpaRepository
    - 얘가 바로 JPA 구현체
    - 기본적인 CRUD 동작 방식
    - CountQueryString
      - 특별한 쿼리에 대한 문자를 나름 들고 있다.
      - 조회 같은 거는 JPA 기능! 
      - 트랜잭션이 잼따
        - 이미 Repository가 걸려 있고 Transactional readonly true로 되어 있다.
      - 하부 기술을 JDBC -> JPA로 바꿔도 Exception 처리는 같다!
        - 하부 구현 기술을 바꿔도, 기존 구현 로직을 바꾸지 않을 수 있도록 잘 설계가 되어 있다.
      - JPA의 모든 변경은 트랜잭션 안에서 해야 된다
        - .save()를 써도 트랜잭션 없이도 가능하다
          - 왜 되냐> -> 이미 transaction이 걸려 있다.
          - 영속성 컨텍스트는 save하고 나오는 순간 끝나버린다.
          - repository 계층에서 트랜잭션에 걸린다~ -> 스프링 데이터 JPA가 트랜잭션을 결국 거는거다.
- 번외
  - @Transactional(readOnlfy = true)의 비밀
    - 트랜잭션을 걸면 DB 커넥션
      - JDBC 메커니즘 -> 걸면, DB 커넥션에 set 오토 커밋 펄스를 넘기면 끝난다 원래는
      - 트랜잭션 리드온리 트루를 걸면 JPA에서 일이 벌어지는데, 플러시를 안해버린다. DB 변경 감지가 안일어나고 데이터를 안보낸다. 
        - readOnlfy니까 데이터 변경이 없다고 가정을 해버린다.
        - 더티 체킹 기능 생략 -> 약간의 성능 최적화
        - DB 드라이버에 따라 최적화 쿼리 카드를 이로 인해 가능하게 할 수 있다고 하는데, ????
        
- 매우 중요!!!
  - save() 메서드
    - 새로운 엔티티면 persist하고, 아니면 merge호출(병합: DB 데이터를 가져와서, save할 데이터를 바꿔치기) - DB에서 일단 가져오고 파라미터로 넘긴 애로 교체, 트랜잭션 끝날 때 DB에 반영 되는
    - merge의 단점 -> db 조회를 한 번 한다.
      - 가급적 merge 쓰지 말자! 
      - db 변경은 변경 감지를 통해!
      - merge는 영속 상태 엔티티가 벗어났을 때, 다시 영속 상태가 되야할 때 쓴다.
      